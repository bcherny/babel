"use strict";

const fs = require("fs");
const t = require("../packages/babel-types");

const NODE_PREFIX = "";

let code = `// NOTE: This file is autogenerated. Do not modify.
// See scripts/generate-typescript-interfaces.js for script used.

export class ${NODE_PREFIX}Comment {
  value: string;
  start: number;
  end: number;
  loc: ${NODE_PREFIX}SourceLocation;
}

export class ${NODE_PREFIX}BlockComment extends ${NODE_PREFIX}Comment {
  type: "BlockComment";
}

export class ${NODE_PREFIX}LineComment extends ${NODE_PREFIX}Comment {
  type: "LineComment";
}

export class ${NODE_PREFIX}SourceLocation {
  start: {
    line: number;
    column: number;
  };

  end: {
    line: number;
    column: number;
  };
}

export class Node {
  leadingComments?: Array<${NODE_PREFIX}Comment> | null;
  innerComments?: Array<${NODE_PREFIX}Comment> | null;
  trailingComments?: Array<${NODE_PREFIX}Comment> | null;
  start?: number | null;
  end?: number | null;
  loc?: ${NODE_PREFIX}SourceLocation | null;
}\n\n`;

//

const lines = [];

for (const type in t.NODE_FIELDS) {
  const fields = t.NODE_FIELDS[type];

  const struct = ['type: "' + type + '";'];
  const args = [];

  Object.keys(t.NODE_FIELDS[type])
    .sort((fieldA, fieldB) => {
      const indexA = t.BUILDER_KEYS[type].indexOf(fieldA);
      const indexB = t.BUILDER_KEYS[type].indexOf(fieldB);
      if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
      if (indexA === -1) return 1;
      if (indexB === -1) return -1;
      return indexA - indexB;
    })
    .forEach(fieldName => {
      const field = fields[fieldName];

      let suffix = "";
      if (field.optional || field.default != null) suffix += "?";

      let typeAnnotation = "any";

      const validate = field.validate;
      if (validate) {
        typeAnnotation = stringifyValidator(validate);
      }

      if (typeAnnotation) {
        suffix += ": " + typeAnnotation;
      }

      args.push(t.toBindingIdentifierName(fieldName) + suffix);

      if (t.isValidIdentifier(fieldName)) {
        struct.push(fieldName + suffix + ";");
      }
    });

  code += `export class ${NODE_PREFIX}${type} extends Node {
  ${struct.join("\n  ").trim()}
}\n\n`;

  // Flow chokes on super() and import() :/
  if (type !== "Super" && type !== "Import") {
    lines.push(
      `export function ${type[0].toLowerCase() + type.slice(1)}(${args.join(
        ", "
      )}): ${NODE_PREFIX}${type};`
    );
  }
}

for (let i = 0; i < t.TYPES.length; i++) {
  let decl = `export function is${
    t.TYPES[i]
  }(node: object, opts?: object | null): `;

  if (t.NODE_FIELDS[t.TYPES[i]]) {
    decl += `node is ${NODE_PREFIX}${t.TYPES[i]};`;
  } else {
    decl += `boolean;`;
  }

  lines.push(decl);
}

lines.push(
  `export function validate(n: BabelNode, key: string, value: mixed): void;`,
  `export function clone<T>(n: T): T;`,
  `export function cloneDeep<T>(n: T): T;`,
  `export function removeProperties<T>(n: T, opts?: {} | null): void;`,
  `export function removePropertiesDeep<T>(n: T, opts?: {} | null): T;`,
  `export type TraversalAncestors = Array<{
    node: BabelNode,
    key: string,
    index?: number,
  }>;
  export type TraversalHandler<T> = (node: BabelNode, parent: TraversalAncestors, type: T) => void;
  export type TraversalHandlers<T> = {
    enter?: TraversalHandler<T>,
    exit?: TraversalHandler<T>,
  };`.replace(/(^|\n) {2}/g, "$1"),
  // eslint-disable-next-line
  `export function traverse<T>(n: BabelNode, h: TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;`
);

for (const type in t.FLIPPED_ALIAS_KEYS) {
  const types = t.FLIPPED_ALIAS_KEYS[type];
  code += `type ${NODE_PREFIX}${type} = ${types
    .map(type => `${NODE_PREFIX}${type}`)
    .join(" | ")};\n`;
}

code += `\ndeclare module "@babel/types" {
  ${lines
    .join("\n")
    .replace(/\n/g, "\n  ")
    .trim()}
}\n`;

//

fs.writeFileSync(__dirname + "/../lib/types.d.ts", code);

function stringifyValidator(validator) {
  if (validator === undefined) {
    return "any";
  }

  if (validator.each) {
    return `Array<${stringifyValidator(validator.each)}>`;
  }

  if (validator.chainOf) {
    return stringifyValidator(validator.chainOf[1]);
  }

  if (validator.oneOf) {
    return validator.oneOf.map(JSON.stringify).join(" | ");
  }

  if (validator.oneOfNodeTypes) {
    return validator.oneOfNodeTypes.map(_ => NODE_PREFIX + _).join(" | ");
  }

  if (validator.type) {
    return NODE_PREFIX + validator.type;
  }

  return ["any"];
}
